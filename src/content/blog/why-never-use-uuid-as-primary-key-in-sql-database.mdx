---
title: 'Why UUIDs Can Wreck Your Database Performance?'
description: "UUIDs seem like a great choice for unique IDs, but they hurt SQL database performance—causing fragmented indexes, bloated storage, and slow queries. Learn why and explore better alternatives like sequential IDs and ULIDs."
pubDate: 'Mar 17 2025'
tags: 'os, database'
group: 'systems'
heroImage: '/blog-placeholder-3.jpg'
authors: ['thehellmaker']
---
import BTreeAnimation from '../../components/blog/btree/BTreeAnimation.tsx';
import { SEQUENTIAL_ACCESS_SEQUENCE_FOR_CACHE_HIT_SIMULATION, SEQUENTIAL_ACCESS_SEQUENCE_FOR_CACHE_MISS_SIMULATION } from '../../components/blog/btree/types.js';

## Why UUIDs Can Wreck Your Database Performance?

UUIDs are an attractive solution for database primary keys. They provide guaranteed uniqueness, work well in distributed systems, and eliminate concerns about ID collisions. However, especially with UUID v4, they can severely impact SQL database performance.

If your database has experienced unexplained slowdowns or increasing storage requirements, your UUID implementation may be responsible. This article explores:

1. The different UUID versions and their characteristics
2. How databases store and access data behind the scenes
3. Why random UUIDs cause significant read and write performance issues
4. Better alternatives that maintain uniqueness without compromising performance
5. Real-world scenarios for when to use each approach based on specific requirements

## Understanding UUIDs: Different Versions for Different Needs

UUIDs are 128-bit identifiers designed to be globally unique without requiring central coordination. Several versions exist, each with distinct generation methods:

### UUID v4 (Random)
UUID v4 generates completely random values without any ordering or pattern:
```
550e8400-e29b-41d4-a716-446655440000  ← completely random
6ba7b810-9dad-11d1-80b4-00c04fd430c8  ← no relation to previous ID
f47ac10b-58cc-4372-a567-0e02b2c3d479  ← inserted later but could sort anywhere
```

These UUIDs have no relationship to each other. They lack sequential ordering, timestamp information, or any predictable pattern. This randomness means records created sequentially could be placed anywhere in the index structure rather than adjacent to one another.

### UUID v7 (Time-Ordered)
UUID v7 incorporates a timestamp component while maintaining uniqueness:
```
018f0f3d-1c3b-7c3b-9c3b-1c3b7c3b9c3b  ← timestamp prefix (018f0f3d = Mar 2023)
018f0f3d-1c3b-7c3b-9c3b-1c3b7c3b9c3c  ← sequential; just +1 in last position
018f0f3e-2a7d-8c4f-a32e-5b6c9d8f3e7a  ← later timestamp, sorts after previous IDs
```

The first 8 characters contain the timestamp component ensuring chronological ordering, while the remaining portions provide uniqueness. Records created in sequence will be physically adjacent in the index structure, improving efficiency.

## Other Sequential ID Types

### Snowflake IDs
Twitter developed this architecture that combines timestamps with machine identifiers:
```
1647794966123118592  ← timestamp (Mar 2023) forms high-order bits
1647794966123118593  ← sequential increment from previous ID
1647795087654387712  ← later timestamp, naturally sorts after previous IDs
```

These provide sequential patterns similar to UUID v7, with additional benefits:
- Half the storage (64 bits vs 128 bits)
- High throughput (4096 IDs per millisecond per node)
- Natural time-based ordering

### ULIDs (Universally Unique Lexicographically Sortable Identifiers)
```
01HNZ7BPQJ9Z8P2NRXGA  ← first 10 chars (01HNZ7BPQJ) are timestamp (Mar 2023)
01HNZ7BPQK9Z8P2NRXGB  ← sequential; sorts immediately after previous ID
01HNZ7CDE59Z8P2NRXGC  ← later timestamp, naturally sorts after previous IDs
```

ULIDs offer several advantages:
- Time-based ordering
- Lexicographically sortable sequence
- Compatible with UUID size (128-bit)
- Better entropy than UUID v7

## Comparison of ID Types

| Feature | UUID v4 | UUID v7 | Snowflake | ULID |
|---------|---------|---------|-----------|------|
| **Structure** | 122 random bits + 6 fixed bits | 48-bit timestamp + 74 random bits + 6 fixed bits | 1-bit sign + 41-bit timestamp + 10-bit node ID + 12-bit sequence | 48-bit timestamp + 80-bit randomness |
| **Bits** | 128 | 128 | 64 | 128 |
| **Ordering** | None (random) | Time-based | Time-based | Time-based |
| **Distribution** | Even (random) | Sequential with timestamp | Sequential with timestamp | Sequential with timestamp |
| **Database Impact** | High fragmentation, poor cache efficiency | Low fragmentation, good caching | Low fragmentation, good caching | Low fragmentation, good caching |
| **Generation** | Independent/local | Requires time synchronization | Coordinated across nodes | Independent with time |
| **Use Case** | Distributed systems, security through randomness | Time series, logs, ordered data | High-volume distributed systems | Modern alternative to UUID v7 |
| **Cache Efficiency** | Poor | Good | Good | Good |
| **Page Splits** | Frequent (5,000-10,000+ per million records) | Minimal (10-20 per million records) | Minimal | Minimal |
| **Example** | 550e8400-e29b-41d4-a716-446655440000 | 018f0f3d-1c3b-7c3b-9c3b-1c3b7c3b9c3b | 1647794966123118592 | 01HNZ7BPQJ9Z8P2NRXGA |
| **Format** | 32 hex chars with hyphens | 32 hex chars with hyphens | Decimal number | 26 Crockford Base32 chars |

## Understanding Database Storage: The Key to Performance

To understand why random UUIDs affect performance, it's important to understand how databases store and access data.

### Database Pages and Storage Hierarchy

1. **Database Pages**: Databases organize data into fixed-size pages (usually 4KB, 8KB, or 16KB). These pages are the fundamental units for I/O operations. A page might contain table data, index entries, or metadata.

2. **Filesystem Blocks**: When a database writes a page to disk, the operating system maps it to filesystem blocks. The database doesn't manage these blocks directly – it requests the OS to read or write a page.

3. **Physical Sectors**: At the hardware level, storage devices organize data into sectors. Modern SSDs and HDDs handle mapping from filesystem blocks to physical sectors internally. Database systems don't interact with sectors directly.

### B-Tree Structure and Page Management

Database indexes, especially B-trees, organize data for efficient retrieval:

1. **Page-Based Storage**: B-trees organize data in fixed-size pages (typically 4-16KB)
2. **Sorted Order**: Data within each page is maintained in sorted order
3. **Fill Factor**: Pages aim to maintain optimal occupancy (usually 70-90%)
4. **Page Splits**: When a page reaches capacity, it splits into two pages

This structure performs optimally for keys inserted in a predictable order. With random keys, the structure becomes inefficient, leading to performance degradation.

## The Performance Impact of Random UUIDs

Let's examine how different UUID strategies affect both read and write performance in databases.

### The Read Problem: Cache Inefficiency and Disk I/O

UUID v4 creates problematic access patterns during reads, as demonstrated in this animation:

<BTreeAnimation client:only="react"
  sequence={SEQUENTIAL_ACCESS_SEQUENCE_FOR_CACHE_MISS_SIMULATION}
  autoPlay={true}
  stepDuration={2000}
/>

When using UUID v4:
1. Each lookup requires navigating to random blocks scattered across storage
2. The database buffer pool becomes less effective as reads access scattered blocks
3. Cache misses increase significantly due to non-sequential access patterns
4. Disk I/O operations increase as blocks must be loaded from various locations
5. Most data retrievals associated with UUID v4 keys require new disk reads

In comparison, UUID v7 enables more efficient read patterns:

<BTreeAnimation client:only="react"
  sequence={SEQUENTIAL_ACCESS_SEQUENCE_FOR_CACHE_HIT_SIMULATION}
  autoPlay={true}
  stepDuration={2000}
/>

With UUID v7:
1. Lookups benefit from temporal locality (related data remains together)
2. The buffer pool efficiently caches recently accessed blocks
3. Cache hit rates increase due to proximate key values
4. Disk I/O operations decrease as recently accessed blocks remain in memory
5. Range scans such as "retrieve all records from the last hour" operate efficiently

## The Write Problem: B-Tree Fragmentation and Page Splits

The read performance issues are significant, but UUID v4's impact on writes creates even more severe performance problems.

### UUID v4 Write Pattern: The Fragmentation Cascade

When using UUID v4 as a primary key, the following sequence occurs during write operations:

1. **Random Insertion Points**: Each new UUID v4 could be placed anywhere in the existing pages
2. **Concentrated Hotspots**: Due to randomness, some pages receive disproportionate numbers of inserts
3. **Frequent Page Splits**: Pages regularly reach capacity and split into two partially-filled pages
4. **B-Tree Balancing**: The B-tree must constantly rebalance itself
5. **Index Fragmentation**: The index becomes increasingly fragmented over time

### Detailed Page Split Analysis

Consider a database with an 8KB B-tree page size and UUID v4 primary keys. When inserting a record:

1. The system navigates the B-tree to locate the appropriate leaf page
2. If the page has sufficient space, the record is inserted
3. If the page is full (common with random UUIDs), a **page split** occurs:
   - The page's data is divided into two roughly equal parts
   - A new page is allocated
   - Half the records move to the new page
   - Parent index pages are updated with new pointers
   - Parent pages may also split, creating a cascade effect

Each page split requires significant resources:
- Reading the original page from disk (if not cached)
- Allocating a new page
- Writing two pages back to disk
- Updating parent nodes (potentially triggering more splits)
- Modifying the free space map

## The Disk I/O Cascade Effect

With UUID v4 keys, page splits occur much more frequently than with sequential IDs, causing:

1. **Write Amplification**: One logical insert can trigger multiple physical page writes
2. **Increased Random I/O**: Writes scatter across the storage device
3. **WAL Overhead**: Each page modification must be logged
4. **Transaction Log Growth**: Transaction logs become significantly larger
5. **Checkpoint Overhead**: Database checkpoints take longer as they flush modified pages

### Quantitative Impact

For a database with 1 million records:

- **Sequential IDs**: Approximately 10-20 page splits during insertion
- **UUID v4**: 5,000-10,000+ page splits for the same data volume

This results in:
- 500-1000× more disk I/O operations
- 2-5× larger index size due to reduced page utilization
- 3-10× longer insertion times

## Comparing Write Patterns: UUID v4 vs. Sequential IDs

### UUID v4 Write Pattern
- **Insertion Distribution**: Random across the entire index
- **Page Utilization**: Typically only 50-70% filled (after splitting)
- **Write Amplification**: 3-5× (each insert potentially triggers multiple writes)
- **Index Fragmentation**: High and increasing over time
- **Storage Overhead**: 30-50% wasted space from partially filled pages

### Sequential ID Write Pattern
- **Insertion Distribution**: Primarily at the right edge of the B-tree
- **Page Utilization**: Typically 90-100% before rightmost page splits
- **Write Amplification**: Minimal (mostly sequential, append-only writes)
- **Index Fragmentation**: Minimal to none
- **Storage Overhead**: Less than 10% wasted space

## Database Maintenance Implications

The excessive page splits from UUID v4 keys necessitate more frequent maintenance:

1. **Index Rebuilds**: Required more frequently to reclaim space and reduce fragmentation
2. **VACUUM Operations**: In PostgreSQL, more aggressive vacuum settings are needed
3. **Statistics Updates**: Optimizer statistics become stale more quickly
4. **Buffer Pool Management**: More complex due to scattered block access

## Making the Right Choice: When to Use Each ID Type

Both random and sequential UUIDs have legitimate use cases. Understanding the appropriate context for each helps with making informed decisions.

### When UUID v4 Makes Sense

Despite the performance challenges, UUID v4 solves important problems in specific contexts:

1. **Distributed Systems Without Coordination**: In microservices, each service can generate IDs independently. For example, an e-commerce platform where orders, inventory, and payments services generate UUIDs locally without central coordination.

2. **Security Through Unpredictability**: The randomness prevents ID guessing attacks. Content management systems using UUID v4 document IDs make it much more difficult for attackers to enumerate valid document URLs.

3. **Write Scalability in NoSQL**: Systems like Cassandra distribute data based on partition keys. Random UUIDs distribute write load evenly across the cluster, beneficial for high-volume IoT platforms.

4. **Client-Side ID Generation**: Mobile applications can generate IDs offline and synchronize later. Field service applications allow technicians to create records offline with UUID v4s that remain unique when synchronized.

### When UUID v7 or Sequential IDs Make Sense

UUID v7 combines uniqueness guarantees with performance benefits:

1. **Time-Series Data**: Patient monitoring systems can use UUID v7 for vital signs data, enabling efficient range queries like "retrieve all readings from the last hour" while maintaining global uniqueness.

2. **Auditable Transaction Logs**: Financial systems benefit from chronologically sortable IDs. Payment processors using UUID v7 for transaction IDs can accurately reconstruct the sequence of events.

3. **Multi-Region Databases**: Global applications with regional database instances can generate IDs that naturally merge in correct time order, such as social media platforms with multiple data centers ordering posts chronologically.

4. **Log Aggregation**: When collecting logs from thousands of servers, UUID v7 IDs ensure events can be efficiently sorted by time while remaining globally unique, important for security monitoring systems.

## Implementation Considerations

### When to Use Each Type

#### UUID v4
- **Distributed Systems**: When central coordination isn't feasible
- **Security Requirements**: When predictable IDs would create security risks
- **Legacy Systems**: When UUID v4 is already implemented

#### UUID v7/Snowflake/ULID
- **New Systems**: When performance optimization is important
- **Time-Sensitive Data**: When chronological ordering provides business value
- **High-Throughput Systems**: When sequential access patterns significantly improve performance

### Optimization Strategies

#### For UUID v4
1. **Index Optimization**
   - Implement covering indexes for common query patterns
   - Use partial indexes to reduce index size
   - Consider hash partitioning to distribute load

2. **Storage Optimization**
   - Implement table partitioning strategies
   - Use materialized views for frequent queries
   - Optimize buffer pool allocation based on access patterns

#### For UUID v7/Sequential IDs
1. **Index Optimization**
   - Implement clustered indexes aligned with access patterns
   - Use range partitioning to match temporal distribution
   - Leverage temporal locality in query planning

2. **Storage Optimization**
   - Design for append-only access patterns
   - Implement time-based partitioning
   - Optimize storage for sequential access

## Further Reading on Database Storage

For those interested in the inner workings of database storage:

1. **Database Page Architecture**
   - [Understanding Database Page Architecture](https://medium.com/@nasserhussain/understanding-database-page-architecture-fc4a99ece3c) by Nasser Hussain explains how databases organize their internal page structure.
   - [How Databases Map Pages to Disk](https://medium.com/@nasserhussain/how-databases-map-pages-to-physical-storage-94ba94ed8be) describes how database storage managers handle page I/O operations.

2. **Storage Access Patterns**
   - [Sequential vs Random I/O](https://vivekbansal.substack.com/p/sequential-vs-random-io) by Vivek Bansal demonstrates why sequential I/O is significantly faster than random I/O.
   - [Database Storage Internals](https://vivekbansal.substack.com/p/database-storage-internals) examines how database page access patterns interact with filesystem and hardware.

3. **Database-Specific Resources**
   - [PostgreSQL Documentation: Page Layout](https://www.postgresql.org/docs/current/storage-page-layout.html) provides details on PostgreSQL's internal page organization.
   - [The Internals of PostgreSQL](http://www.interdb.jp/pg/pgsql01.html) by Hironobu Suzuki covers PostgreSQL's storage and buffer management.

## Conclusion

The choice between UUID v4 and sequential identifiers (UUID v7, Snowflake, ULID) significantly impacts database performance. UUID v4's randomness creates the inefficient access patterns shown in the first animation, while sequential IDs enable the optimized patterns in the second.

For most applications, sequential identifiers provide an optimal balance between uniqueness and performance. When UUID v4 is necessary, careful system design and strategic optimization can help mitigate the performance impact.

Understanding these differences enables better architectural decisions. The UUID version selected substantially affects database performance, so choosing the right ID type for specific requirements ensures both uniqueness and efficiency.